{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from 'react';\nimport { useBooks } from '../contexts/BookContext';\nimport { useUser } from '../contexts/UserContext';\nimport { generateRecommendations, getRecommendationReason } from '../utils/helpers';\nimport { getBooksByGenre, getTrendingBooks, getPopularBooks } from '../services/bookAPI';\nexport const useRecommendations = () => {\n  _s();\n  const {\n    ratings,\n    readingList,\n    searchResults\n  } = useBooks();\n  const {\n    preferences\n  } = useUser();\n  const [recommendations, setRecommendations] = useState([]);\n  const [trendingBooks, setTrendingBooks] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const generatePersonalizedRecommendations = async () => {\n    setLoading(true);\n    setError(null);\n    try {\n      var _preferences$genres;\n      console.log('Generating recommendations...', {\n        ratingsCount: Object.keys(ratings).length,\n        genresCount: ((_preferences$genres = preferences.genres) === null || _preferences$genres === void 0 ? void 0 : _preferences$genres.length) || 0,\n        readingListCount: readingList.length\n      });\n\n      // If user has ratings, use rating-based recommendations\n      if (Object.keys(ratings).length > 0) {\n        await generateRatingBasedRecommendations();\n      }\n      // If user has genre preferences but no ratings\n      else if (preferences.genres && preferences.genres.length > 0) {\n        await generateGenreBasedRecommendations();\n      }\n      // If user has books in reading list but no preferences\n      else if (readingList.length > 0) {\n        await generateReadingListBasedRecommendations();\n      }\n      // Fallback to popular books\n      else {\n        await generatePopularRecommendations();\n      }\n    } catch (err) {\n      setError('Failed to generate recommendations');\n      console.error('Recommendation error:', err);\n      // Fallback to popular books on error\n      await generatePopularRecommendations();\n    } finally {\n      setLoading(false);\n    }\n  };\n  const generateRatingBasedRecommendations = async () => {\n    try {\n      // Get genres from highly rated books\n      const highlyRatedGenres = getGenresFromRatedBooks();\n      if (highlyRatedGenres.length === 0) {\n        await generateGenreBasedRecommendations();\n        return;\n      }\n\n      // Fetch books from top genres\n      const genrePromises = highlyRatedGenres.slice(0, 3).map(genre => getBooksByGenre(genre, 8));\n      const genreResults = await Promise.all(genrePromises);\n      const allBooks = genreResults.flat();\n\n      // Remove duplicates and books already in reading list\n      const filteredBooks = filterAndDeduplicateBooks(allBooks);\n      const recsWithReasons = filteredBooks.slice(0, 20).map(book => ({\n        ...book,\n        recommendationReason: `You rated ${highlyRatedGenres[0]} books highly`\n      }));\n      setRecommendations(recsWithReasons);\n    } catch (error) {\n      console.error('Rating-based recommendations error:', error);\n      throw error;\n    }\n  };\n  const generateGenreBasedRecommendations = async () => {\n    try {\n      const genrePromises = preferences.genres.slice(0, 3).map(genre => getBooksByGenre(genre, 10));\n      const genreResults = await Promise.all(genrePromises);\n      const allBooks = genreResults.flat();\n      const filteredBooks = filterAndDeduplicateBooks(allBooks);\n      const recsWithReasons = filteredBooks.slice(0, 20).map(book => ({\n        ...book,\n        recommendationReason: `Based on your interest in ${preferences.genres.slice(0, 2).join(' and ')}`\n      }));\n      setRecommendations(recsWithReasons);\n    } catch (error) {\n      console.error('Genre-based recommendations error:', error);\n      throw error;\n    }\n  };\n  const generateReadingListBasedRecommendations = async () => {\n    try {\n      // Extract genres from reading list\n      const genres = [...new Set(readingList.flatMap(book => book.categories || []).filter(Boolean))].slice(0, 3);\n      if (genres.length === 0) {\n        await generatePopularRecommendations();\n        return;\n      }\n      const genrePromises = genres.map(genre => getBooksByGenre(genre, 8));\n      const genreResults = await Promise.all(genrePromises);\n      const allBooks = genreResults.flat();\n      const filteredBooks = filterAndDeduplicateBooks(allBooks);\n      const recsWithReasons = filteredBooks.slice(0, 20).map(book => ({\n        ...book,\n        recommendationReason: `Similar to books in your library`\n      }));\n      setRecommendations(recsWithReasons);\n    } catch (error) {\n      console.error('Reading list based recommendations error:', error);\n      throw error;\n    }\n  };\n  const generatePopularRecommendations = async () => {\n    try {\n      const popularBooks = await getPopularBooks(20);\n      const filteredBooks = filterAndDeduplicateBooks(popularBooks);\n      const recsWithReasons = filteredBooks.map(book => ({\n        ...book,\n        recommendationReason: 'Popular with other readers'\n      }));\n      setRecommendations(recsWithReasons);\n    } catch (error) {\n      console.error('Popular recommendations error:', error);\n      setRecommendations([]);\n    }\n  };\n  const getGenresFromRatedBooks = () => {\n    const genres = [];\n    Object.entries(ratings).forEach(([bookId, rating]) => {\n      if (rating >= 4) {\n        const book = readingList.find(b => b.id === bookId);\n        if (book && book.categories) {\n          genres.push(...book.categories);\n        }\n      }\n    });\n\n    // Count genre frequency and return top genres\n    const genreCount = {};\n    genres.forEach(genre => {\n      genreCount[genre] = (genreCount[genre] || 0) + 1;\n    });\n    return Object.entries(genreCount).sort(([, a], [, b]) => b - a).map(([genre]) => genre).slice(0, 3);\n  };\n  const filterAndDeduplicateBooks = books => {\n    const readingListIds = readingList.map(book => book.id);\n    const seen = new Set();\n    return books.filter(book => {\n      if (seen.has(book.id) || readingListIds.includes(book.id)) {\n        return false;\n      }\n      seen.add(book.id);\n      return true;\n    });\n  };\n  const loadTrendingBooks = async () => {\n    try {\n      const trending = await getTrendingBooks(12);\n      const filteredTrending = filterAndDeduplicateBooks(trending);\n      setTrendingBooks(filteredTrending);\n    } catch (err) {\n      console.error('Trending books error:', err);\n      // Fallback to popular books\n      try {\n        const popular = await getPopularBooks(12);\n        const filteredPopular = filterAndDeduplicateBooks(popular);\n        setTrendingBooks(filteredPopular);\n      } catch (fallbackErr) {\n        console.error('Fallback trending books error:', fallbackErr);\n      }\n    }\n  };\n  useEffect(() => {\n    generatePersonalizedRecommendations();\n  }, [ratings, preferences.genres, preferences.authors, readingList.length]);\n  useEffect(() => {\n    loadTrendingBooks();\n  }, [readingList.length]);\n  return {\n    recommendations,\n    trendingBooks,\n    loading,\n    error,\n    refreshRecommendations: generatePersonalizedRecommendations\n  };\n};\n_s(useRecommendations, \"MNeF594rq/BLKYlPVjTy0vWHmzg=\", false, function () {\n  return [useBooks, useUser];\n});","map":{"version":3,"names":["useState","useEffect","useBooks","useUser","generateRecommendations","getRecommendationReason","getBooksByGenre","getTrendingBooks","getPopularBooks","useRecommendations","_s","ratings","readingList","searchResults","preferences","recommendations","setRecommendations","trendingBooks","setTrendingBooks","loading","setLoading","error","setError","generatePersonalizedRecommendations","_preferences$genres","console","log","ratingsCount","Object","keys","length","genresCount","genres","readingListCount","generateRatingBasedRecommendations","generateGenreBasedRecommendations","generateReadingListBasedRecommendations","generatePopularRecommendations","err","highlyRatedGenres","getGenresFromRatedBooks","genrePromises","slice","map","genre","genreResults","Promise","all","allBooks","flat","filteredBooks","filterAndDeduplicateBooks","recsWithReasons","book","recommendationReason","join","Set","flatMap","categories","filter","Boolean","popularBooks","entries","forEach","bookId","rating","find","b","id","push","genreCount","sort","a","books","readingListIds","seen","has","includes","add","loadTrendingBooks","trending","filteredTrending","popular","filteredPopular","fallbackErr","authors","refreshRecommendations"],"sources":["C:/Users/T K/Desktop/personalized-book-recommendations/src/hooks/useRecommendations.js"],"sourcesContent":["import { useState, useEffect } from 'react';\r\nimport { useBooks } from '../contexts/BookContext';\r\nimport { useUser } from '../contexts/UserContext';\r\nimport { generateRecommendations, getRecommendationReason } from '../utils/helpers';\r\nimport { getBooksByGenre, getTrendingBooks, getPopularBooks } from '../services/bookAPI';\r\n\r\nexport const useRecommendations = () => {\r\n  const { ratings, readingList, searchResults } = useBooks();\r\n  const { preferences } = useUser();\r\n  const [recommendations, setRecommendations] = useState([]);\r\n  const [trendingBooks, setTrendingBooks] = useState([]);\r\n  const [loading, setLoading] = useState(false);\r\n  const [error, setError] = useState(null);\r\n\r\n  const generatePersonalizedRecommendations = async () => {\r\n    setLoading(true);\r\n    setError(null);\r\n\r\n    try {\r\n      console.log('Generating recommendations...', {\r\n        ratingsCount: Object.keys(ratings).length,\r\n        genresCount: preferences.genres?.length || 0,\r\n        readingListCount: readingList.length\r\n      });\r\n\r\n      // If user has ratings, use rating-based recommendations\r\n      if (Object.keys(ratings).length > 0) {\r\n        await generateRatingBasedRecommendations();\r\n      } \r\n      // If user has genre preferences but no ratings\r\n      else if (preferences.genres && preferences.genres.length > 0) {\r\n        await generateGenreBasedRecommendations();\r\n      }\r\n      // If user has books in reading list but no preferences\r\n      else if (readingList.length > 0) {\r\n        await generateReadingListBasedRecommendations();\r\n      }\r\n      // Fallback to popular books\r\n      else {\r\n        await generatePopularRecommendations();\r\n      }\r\n    } catch (err) {\r\n      setError('Failed to generate recommendations');\r\n      console.error('Recommendation error:', err);\r\n      // Fallback to popular books on error\r\n      await generatePopularRecommendations();\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const generateRatingBasedRecommendations = async () => {\r\n    try {\r\n      // Get genres from highly rated books\r\n      const highlyRatedGenres = getGenresFromRatedBooks();\r\n      \r\n      if (highlyRatedGenres.length === 0) {\r\n        await generateGenreBasedRecommendations();\r\n        return;\r\n      }\r\n\r\n      // Fetch books from top genres\r\n      const genrePromises = highlyRatedGenres.slice(0, 3).map(genre => \r\n        getBooksByGenre(genre, 8)\r\n      );\r\n      \r\n      const genreResults = await Promise.all(genrePromises);\r\n      const allBooks = genreResults.flat();\r\n      \r\n      // Remove duplicates and books already in reading list\r\n      const filteredBooks = filterAndDeduplicateBooks(allBooks);\r\n      \r\n      const recsWithReasons = filteredBooks.slice(0, 20).map(book => ({\r\n        ...book,\r\n        recommendationReason: `You rated ${highlyRatedGenres[0]} books highly`\r\n      }));\r\n\r\n      setRecommendations(recsWithReasons);\r\n    } catch (error) {\r\n      console.error('Rating-based recommendations error:', error);\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  const generateGenreBasedRecommendations = async () => {\r\n    try {\r\n      const genrePromises = preferences.genres.slice(0, 3).map(genre => \r\n        getBooksByGenre(genre, 10)\r\n      );\r\n      \r\n      const genreResults = await Promise.all(genrePromises);\r\n      const allBooks = genreResults.flat();\r\n      \r\n      const filteredBooks = filterAndDeduplicateBooks(allBooks);\r\n      \r\n      const recsWithReasons = filteredBooks.slice(0, 20).map(book => ({\r\n        ...book,\r\n        recommendationReason: `Based on your interest in ${preferences.genres.slice(0, 2).join(' and ')}`\r\n      }));\r\n\r\n      setRecommendations(recsWithReasons);\r\n    } catch (error) {\r\n      console.error('Genre-based recommendations error:', error);\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  const generateReadingListBasedRecommendations = async () => {\r\n    try {\r\n      // Extract genres from reading list\r\n      const genres = [...new Set(\r\n        readingList\r\n          .flatMap(book => book.categories || [])\r\n          .filter(Boolean)\r\n      )].slice(0, 3);\r\n\r\n      if (genres.length === 0) {\r\n        await generatePopularRecommendations();\r\n        return;\r\n      }\r\n\r\n      const genrePromises = genres.map(genre => getBooksByGenre(genre, 8));\r\n      const genreResults = await Promise.all(genrePromises);\r\n      const allBooks = genreResults.flat();\r\n      \r\n      const filteredBooks = filterAndDeduplicateBooks(allBooks);\r\n      \r\n      const recsWithReasons = filteredBooks.slice(0, 20).map(book => ({\r\n        ...book,\r\n        recommendationReason: `Similar to books in your library`\r\n      }));\r\n\r\n      setRecommendations(recsWithReasons);\r\n    } catch (error) {\r\n      console.error('Reading list based recommendations error:', error);\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  const generatePopularRecommendations = async () => {\r\n    try {\r\n      const popularBooks = await getPopularBooks(20);\r\n      const filteredBooks = filterAndDeduplicateBooks(popularBooks);\r\n      \r\n      const recsWithReasons = filteredBooks.map(book => ({\r\n        ...book,\r\n        recommendationReason: 'Popular with other readers'\r\n      }));\r\n\r\n      setRecommendations(recsWithReasons);\r\n    } catch (error) {\r\n      console.error('Popular recommendations error:', error);\r\n      setRecommendations([]);\r\n    }\r\n  };\r\n\r\n  const getGenresFromRatedBooks = () => {\r\n    const genres = [];\r\n    Object.entries(ratings).forEach(([bookId, rating]) => {\r\n      if (rating >= 4) {\r\n        const book = readingList.find(b => b.id === bookId);\r\n        if (book && book.categories) {\r\n          genres.push(...book.categories);\r\n        }\r\n      }\r\n    });\r\n    \r\n    // Count genre frequency and return top genres\r\n    const genreCount = {};\r\n    genres.forEach(genre => {\r\n      genreCount[genre] = (genreCount[genre] || 0) + 1;\r\n    });\r\n    \r\n    return Object.entries(genreCount)\r\n      .sort(([,a], [,b]) => b - a)\r\n      .map(([genre]) => genre)\r\n      .slice(0, 3);\r\n  };\r\n\r\n  const filterAndDeduplicateBooks = (books) => {\r\n    const readingListIds = readingList.map(book => book.id);\r\n    const seen = new Set();\r\n    \r\n    return books.filter(book => {\r\n      if (seen.has(book.id) || readingListIds.includes(book.id)) {\r\n        return false;\r\n      }\r\n      seen.add(book.id);\r\n      return true;\r\n    });\r\n  };\r\n\r\n  const loadTrendingBooks = async () => {\r\n    try {\r\n      const trending = await getTrendingBooks(12);\r\n      const filteredTrending = filterAndDeduplicateBooks(trending);\r\n      setTrendingBooks(filteredTrending);\r\n    } catch (err) {\r\n      console.error('Trending books error:', err);\r\n      // Fallback to popular books\r\n      try {\r\n        const popular = await getPopularBooks(12);\r\n        const filteredPopular = filterAndDeduplicateBooks(popular);\r\n        setTrendingBooks(filteredPopular);\r\n      } catch (fallbackErr) {\r\n        console.error('Fallback trending books error:', fallbackErr);\r\n      }\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    generatePersonalizedRecommendations();\r\n  }, [ratings, preferences.genres, preferences.authors, readingList.length]);\r\n\r\n  useEffect(() => {\r\n    loadTrendingBooks();\r\n  }, [readingList.length]);\r\n\r\n  return {\r\n    recommendations,\r\n    trendingBooks,\r\n    loading,\r\n    error,\r\n    refreshRecommendations: generatePersonalizedRecommendations\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}